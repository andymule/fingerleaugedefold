local M = {}

-- Import the global settings
local settings = require("main.game_settings")

function init(self)
    -- Initial properties
    self.speed = 0
    self.max_speed = 400
    self.accel = 1000
    self.input_active = false
    
    -- Set initial position in the center of the screen
    self.pos = go.get_position()
    
    -- Track velocity for momentum
    self.velocity = vmath.vector3(0, 0, 0)
    
    -- Track current mouse/touch position
    self.current_pointer_pos = vmath.vector3(0, 0, 0)
    
    -- Enable input for this game object
    msg.post(".", "acquire_input_focus")
    print("Ball initialized at position:", go.get_position())
end

function on_reload(self)
    print("reloaded!")
end

function final(self)
    -- Release input focus when the script is finalized
    msg.post(".", "release_input_focus")
    
    -- Add your finalization code here
    -- Remove this function if not needed
end

function update(self, dt)
    -- If input is active, always update target to current pointer position
    if self.input_active then
        self.target_pos = self.current_pointer_pos
        
        -- Add debug markers along the path if enabled (only occasionally)
        if settings.render_click_points and math.random() < 0.05 then
            factory.create("#marker_factory", self.target_pos)
        end
        
        -- When input is active, accelerate toward target
        if self.target_pos then
            -- Calculate direction vector to target
            local dir = self.target_pos - self.pos
            local distance = vmath.length(dir)
            
            -- Only accelerate if we're not already at the target
            if distance > 10 then
                -- Normalize direction and apply acceleration
                dir = vmath.normalize(dir)
                
                -- Apply acceleration to velocity
                self.velocity = self.velocity + dir * self.accel * dt
                
                -- Cap at max speed
                local current_speed = vmath.length(self.velocity)
                if current_speed > self.max_speed then
                    self.velocity = self.velocity * (self.max_speed / current_speed)
                end
            end
        end
    else
        -- No input, apply light friction to gradually slow down
        local friction = 0.99  -- Higher values = less friction
        self.velocity = self.velocity * friction
        
        -- Stop if very slow
        if vmath.length(self.velocity) < 5 then
            self.velocity = vmath.vector3(0, 0, 0)
        end
    end
    
    -- Always apply velocity to position
    if vmath.length(self.velocity) > 0 then
        self.pos = self.pos + self.velocity * dt
        go.set_position(self.pos)
    end
end

-- Helper function to convert screen coordinates to world coordinates
function screen_to_world(x, y)
    -- Get the render configuration
    local width = tonumber(sys.get_config("display.width"))
    local height = tonumber(sys.get_config("display.height"))
    
    -- For simple cases, we can just use the screen coordinates directly
    return vmath.vector3(x, y, 0)
end

function on_input(self, action_id, action)
    -- Always track the current pointer position on any touch/mouse event
    if action_id == hash("touch") then
        -- Update current pointer position
        self.current_pointer_pos = vmath.vector3(action.x, action.y, 0)
        
        -- Touch/click started
        if action.pressed then
            self.input_active = true
            
            -- Only spawn debug marker if setting is enabled
            if settings.render_click_points then
                factory.create("#marker_factory", self.current_pointer_pos)
            end
            
        -- Touch/click ended
        elseif action.released then
            self.input_active = false
            -- Don't reset velocity - let it keep its momentum
        end
        
        return true
    end
    
    return false
end

return M 